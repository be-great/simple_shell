#include "main.h"

static built_ins built_insFunc[] = {
		{"cd", (builtinFunc)cd_command},
		{"exit", (builtinFunc)exit_cmd},
		{"env", (builtinFunc)print_env},
		{NULL, NULL}

	};

/**
 * findBuiltin - a function to find the builtin command from the struct list
 * @name: th eneame fo the command and builtin to compare
 * Return: a pointer to corresponding structure, or NULL
*/

built_ins *findBuiltin(const char *name)
{
	int i;

	for (i = 0; built_insFunc[i].name != NULL; i++)
	{
		if (strcmp(name, built_insFunc[i].name) == 0)
		{
			return (&built_insFunc[i]);
		}
	}

	return (NULL);
}



/**
 * execute_builtins - a function for handling the biltins
 * @tokens: the tokens from the argument
 * @num_tokens: the number of tokens
 * @error_info: struct of the error information
 * @line: the line gotten
 * Return: void
*/

int execute_builtins(char **tokens, int num_tokens, error_h_t *error_info, char *line)
{
	const char *command = tokens[0];
	built_ins *builtin;
	int status = 0;

	if (num_tokens > 0)
	{
		builtin = findBuiltin(command);

		if (builtin != NULL)
		{
			if (strcmp(command, "env") == 0)
			{
				void *result = builtin->handler(tokens);
				return (0);
			}
			else if (strcmp(command, "cd") == 0)
			{
				int *result = (int)builtin->handler(tokens);
				return (0);
			}
			else if (strcmp(command, "exit") == 0)
			{
				status = exit_cmd(tokens, error_info);
				error_info->status = status;
				if (status != 2)
				{
					cleanup_memory(tokens, num_tokens, error_info);
					free(line);
					exit(status);
				}
				return (0);
			}
		}
	}

}


